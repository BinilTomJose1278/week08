# CD Pipeline for Production Deployment
name: CD - Production Deployment

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'k8s/**'
      - '.github/workflows/cd-production.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
  IMAGE_TAG: ${{ github.sha }}-${{ github.run_id }}

jobs:
  # Build Production Images
  build-production-images:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to Azure Container Registry
        run: az acr login --name wk09cacrbinil

      - name: Build and Push Product Service Image
        run: |
          DOCKER_BUILDKIT=0 docker build -t wk09cacrbinil.azurecr.io/product_service:prod-${{ env.IMAGE_TAG }} ./backend/product_service/
          DOCKER_BUILDKIT=0 docker build -t wk09cacrbinil.azurecr.io/product_service:latest ./backend/product_service/
          docker push wk09cacrbinil.azurecr.io/product_service:prod-${{ env.IMAGE_TAG }}
          docker push wk09cacrbinil.azurecr.io/product_service:latest

      - name: Build and Push Order Service Image
        run: |
          DOCKER_BUILDKIT=0 docker build -t wk09cacrbinil.azurecr.io/order_service:prod-${{ env.IMAGE_TAG }} ./backend/order_service/
          DOCKER_BUILDKIT=0 docker build -t wk09cacrbinil.azurecr.io/order_service:latest ./backend/order_service/
          docker push wk09cacrbinil.azurecr.io/order_service:prod-${{ env.IMAGE_TAG }}
          docker push wk09cacrbinil.azurecr.io/order_service:latest

      - name: Build and Push Frontend Image
        run: |
          DOCKER_BUILDKIT=0 docker build -t wk09cacrbinil.azurecr.io/frontend:prod-${{ env.IMAGE_TAG }} ./frontend/
          DOCKER_BUILDKIT=0 docker build -t wk09cacrbinil.azurecr.io/frontend:latest ./frontend/
          docker push wk09cacrbinil.azurecr.io/frontend:prod-${{ env.IMAGE_TAG }}
          docker push wk09cacrbinil.azurecr.io/frontend:latest

      - name: Logout from Azure
        run: az logout
        if: always()

  # Deploy Backend Services
  deploy-backend:
    runs-on: ubuntu-latest
    needs: build-production-images
    environment: Production
    
    outputs:
      product_service_ip: ${{ steps.get-backend-ips.outputs.product_ip }}
      order_service_ip: ${{ steps.get-backend-ips.outputs.order_ip }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Azure Environment
        uses: ./.github/workflows/shared-actions.yml

      - name: Deploy Backend Infrastructure
        run: |
          echo "Deploying backend infrastructure to production..."
          cd k8s/
          
          # Update image tags for production
          sed -i "s|image: .*product_service:.*|image: wk09cacrbinil.azurecr.io/product_service:latest|g" product-service.yaml
          sed -i "s|image: .*order_service:.*|image: wk09cacrbinil.azurecr.io/order_service:latest|g" order-service.yaml
          
          kubectl apply -f configmaps.yaml
          kubectl apply -f secrets.yaml
          kubectl apply -f product-db.yaml
          kubectl apply -f order-db.yaml

      - name: Deploy Backend Microservices
        run: |
          echo "Deploying backend microservices to production..."
          cd k8s/
          kubectl apply -f product-service.yaml
          kubectl apply -f order-service.yaml

      - name: Wait for Backend Services
        run: |
          echo "Waiting for backend services to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/product-service-w09e1
          kubectl wait --for=condition=available --timeout=300s deployment/order-service-w09e1

      - name: Get Backend Service IPs
        id: get-backend-ips
        run: |
          echo "Getting backend service IPs..."
          PRODUCT_IP=""
          ORDER_IP=""
          
          # Wait for IPs to be assigned (up to 5 minutes)
          for i in $(seq 1 60); do
            echo "Attempt $i/60 to get IPs..."
            PRODUCT_IP=$(kubectl get service product-service-w09e1 -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            ORDER_IP=$(kubectl get service order-service-w09e1 -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

            if [[ -n "$PRODUCT_IP" && -n "$ORDER_IP" ]]; then
              echo "All backend LoadBalancer IPs assigned!"
              echo "Product Service IP: $PRODUCT_IP"
              echo "Order Service IP: $ORDER_IP"
              break
            fi
            sleep 5
          done
          
          if [[ -z "$PRODUCT_IP" || -z "$ORDER_IP" ]]; then
            echo "Error: One or more LoadBalancer IPs not assigned after timeout."
            exit 1
          fi
          
          echo "product_ip=http://$PRODUCT_IP:8000" >> $GITHUB_OUTPUT
          echo "order_ip=http://$ORDER_IP:8001" >> $GITHUB_OUTPUT

      - name: Health Check Backend Services
        run: |
          echo "Performing health checks on backend services..."
          sleep 30  # Wait for services to be fully ready
          
          # Test product service
          curl -f ${{ steps.get-backend-ips.outputs.product_ip }}/health || exit 1
          echo "âœ… Product service health check passed"
          
          # Test order service  
          curl -f ${{ steps.get-backend-ips.outputs.order_ip }}/health || exit 1
          echo "âœ… Order service health check passed"

  # Deploy Frontend
  deploy-frontend:
    runs-on: ubuntu-latest
    needs: deploy-backend
    environment: Production
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to Azure Container Registry
        run: az acr login --name ${{ env.ACR_LOGIN_SERVER }}

      - name: Inject Backend URLs into Frontend
        run: |
          echo "Injecting backend URLs into frontend configuration..."
          sed -i "s|_PRODUCT_API_URL_|${{ needs.deploy-backend.outputs.product_service_ip }}|g" frontend/main.js
          sed -i "s|_ORDER_API_URL_|${{ needs.deploy-backend.outputs.order_service_ip }}|g" frontend/main.js
          
          echo "--- main.js after injection ---"
          cat frontend/main.js
          echo "--------------------------------"

      - name: Build and Push Updated Frontend Image
        run: |
          echo "Building and pushing updated frontend image..."
          DOCKER_BUILDKIT=0 docker build -t wk09cacrbinil.azurecr.io/frontend:latest ./frontend/
          docker push wk09cacrbinil.azurecr.io/frontend:latest

      - name: Setup Kubernetes Context
        run: |
          az aks get-credentials --resource-group ${{ secrets.AKS_RESOURCE_GROUP }} --name ${{ secrets.AKS_CLUSTER_NAME }} --overwrite-existing

      - name: Deploy Frontend
        run: |
          echo "Deploying frontend to production..."
          cd k8s/
          
          # Ensure image reference points to latest
          sed -i "s|image: .*frontend:.*|image: wk09cacrbinil.azurecr.io/frontend:latest|g" frontend.yaml
          
          kubectl apply -f frontend.yaml
          kubectl rollout status deployment/frontend --timeout=300s

      - name: Wait for Frontend Service
        run: |
          echo "Waiting for frontend service to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/frontend

      - name: Get Frontend Service IP
        id: get-frontend-ip
        run: |
          FRONTEND_IP=$(kubectl get service frontend-w09e1 -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "frontend_ip=http://$FRONTEND_IP" >> $GITHUB_OUTPUT
          echo "Frontend deployed at: http://$FRONTEND_IP"

      - name: Final Health Check
        run: |
          echo "Performing final health checks..."
          sleep 30  # Wait for all services to be fully ready
          
          # Test all services
          curl -f ${{ needs.deploy-backend.outputs.product_service_ip }}/health || exit 1
          curl -f ${{ needs.deploy-backend.outputs.order_service_ip }}/health || exit 1
          curl -f ${{ steps.get-frontend-ip.outputs.frontend_ip }} || exit 1
          
          echo "âœ… All services are healthy!"

      - name: Logout from Azure
        run: az logout
        if: always()

  # Post-Deployment Verification
  post-deployment-verification:
    runs-on: ubuntu-latest
    needs: [deploy-backend, deploy-frontend]
    if: always() && needs.deploy-backend.result == 'success' && needs.deploy-frontend.result == 'success'
    
    steps:
      - name: Deployment Summary
        run: |
          echo "ðŸŽ‰ Production Deployment Successful!"
          echo "=================================="
          echo "Frontend URL: ${{ needs.deploy-frontend.outputs.frontend_ip || 'Not available' }}"
          echo "Product API: ${{ needs.deploy-backend.outputs.product_service_ip }}"
          echo "Order API: ${{ needs.deploy-backend.outputs.order_service_ip }}"
          echo "=================================="
          echo "Deployment completed at: $(date)"
          echo "Git commit: ${{ github.sha }}"
          echo "Workflow run: ${{ github.run_id }}"

      - name: Create Deployment Notification
        run: |
          echo "Creating deployment notification..."
          # This could be extended to send notifications to Slack, Teams, etc.
          echo "Deployment notification created for commit ${{ github.sha }}"
